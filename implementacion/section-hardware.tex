\section{COMPONENTE HARDWARE}

El componente hardware se ha implementado utilizando dos lenguajes de programación; \emph{Wiring} para el microprocesador ATmega32u4, Python para el procesador \emph{Atheros AR9331}.

\subsection{Configurando el sistema}

El primer paso es configurar la placa de Arduino Yún para empezar a trabajar sobre ella. Para ello Yún corre una distribución de Linux llamada \emph{OpenWrt-Yun}, basado en \emph{OpenWrt}, la cual nos permite acceder vía \emph{ssh} o vía web para poder configurarla. 

La primera vez que se conecta Arduino Yún se crea una red sin encriptar para poder conectarnos a ella y poder configurarla, el nombre de la red tiene el formato \emph{ArduinoYun-XXXXXXXXXXXX}. Una vez conectados se accede al panel web de configuración a través de la url \emph{http://arduino.local} y se nos muestra la siguiente ventana:

\begin{figure}[H]
    \centering
    \includegraphics[keepaspectratio,width=0.6\textwidth]{YunWebPassword.eps}
    \caption{Arduino Yún Web Password}\label{fig:yun-web-password}
\end{figure}

La contraseña por defecto es \emph{Arduino} y nos permite acceder al panel de diagnóstico donde nos muestra información sobre la red WiFi y la conexión Ethernet. Además, nos permite acceder al panel de configuración:

\begin{figure}[H]
    \centering
    \includegraphics[keepaspectratio,width=0.6\textwidth]{YunWebDiagnostic.eps}
    \caption{Arduino Yún Web Diagnostic}\label{fig:yun-web-diagnostic}
\end{figure}

El panel de configuración nos permite nombrar nuestra placa Arduino, establecer una contraseña de acceso, configurar la zona horaria y por último, y lo más importante, decirle a que red WiFi debe conectarse.

\begin{figure}[H]
    \centering
    \includegraphics[keepaspectratio,width=0.6\textwidth]{YunWebConfig.eps}
    \caption{Arduino Yún Web Config}\label{fig:yun-web-config}
\end{figure}

Una vez se guarda la nueva configuración la distribución Linux se reinicia y automáticamente se conectará a la red WiFi que hayamos establecido, indicándonos que nos conectemos a la misma WiFi mediante la siguiente ventana:

\begin{figure}[H]
    \centering
    \includegraphics[keepaspectratio,width=0.6\textwidth]{YunRebooting.eps}
    \caption{Arduino Yún Web Rebooting}\label{fig:yun-web-rebooting}
\end{figure}

Pasado varios segundos automáticamente se nos volverá a conectar a la página de configuración de Arduino donde tendremos que introducir la nueva contraseña para acceder.

\subsection{Problemas detectados}

La versión de Linux que trae la placa Arduino no viene con las librerías para utilizar el puerto USB en modo HID (\emph{Human Interface Device}) por lo que no reconoce el lector de códigos de barras USB. Para configurarlo se han tenido que bajar las librerías e instalarlas a través de SSH.

\begin{enumerate}
	
	\item Descargar y guardar en la memoria micro-sd (\emph{/mnt/sda1/}) las dos siguientes librerías:

		\begin{itemize}
			\item kmod-hid-generic\_3.8.3-1\_ar71xx.ipk
			\item kmod-hid\_3.8.3-1\_ar71xx.ipk
		\end{itemize}

	\item Actualizar el sistema de paquetes e instalar las dos siguientes librerías para permitir la instalación de las librerías anteriores:

		\begin{lstlisting}
opkg update
opkg install kmod-input-core
opkg install kmod-input-evdev
		\end{lstlisting}

	\item Instalar las librerías de la micro-sd:

		\begin{lstlisting}
rm /tmp/opkg-lists/*
opkg install /mnt/sda1/kmod-hid\_3.8.3-1\_ar71xx.ipk
opkg install /mnt/sda1/kmod-hid-generic\_3.8.3-1\_ar71xx.ipk
		\end{lstlisting}

	\item Instalar el driver HID:

		\begin{lstlisting}
opkg update
opkg install kmod-usb-hid
		\end{lstlisting}

	\item Cargar el driver HID en el Kernel:

		\begin{lstlisting}
insmod hid-generic
echo "hid-generic" >>/etc/modules.d/62-hid-generic
		\end{lstlisting}

	\item Reiniciar Linux:

		\begin{lstlisting}
reboot
		\end{lstlisting}

	\item Enchufar el lector de tarjetas USB y comprobar que funciona:

		\begin{lstlisting}
cat /dev/input/event1 | hexdump
		\end{lstlisting}

\end{enumerate}

Con esta configuración Linux es capaz de cargar el dispositivo USB, pero, si se desenchufa y se vuelve a enchufar a veces no carga y da problemas. Por suerte, el \emph{23 de Abril de 2014} han sacado una nueva versión de \emph{OpenWrt-Yun} que corrige estos errores, e introduce las siguientes mejoras:

	\begin{itemize}
		\item OpenWrt
			\begin{itemize}
 				\item wget now supports ssl
 				\item Fixed fuses values in run-avrdude
 				\item nano is now built-in (no need to become ''vi'' experts any more)
 				\item Updated ruby to 1.9.3-p429
 				\item Fixed USB port stability (when using it both with a pen drive or as a serial device)
 				\item Patched dhcp script to fix ethernet routing issue
 				\item Added lots of webcam modules
 				\item Fixed USB keyboard support
 				\item Heartbleed http://heartbleed.com/
 				\item Linux side ready visual notification: when linux boot completes, the usb led lights up (it's bright white)
 				\item Disk space expander tutorial: using an micro SD card to have gigabytes of disk space
 				\item Added ''upgrade-all'' script for easier massive upgrade of packages (available only after having followed the ExpandingYunDiskSpace tutorial)
 				\item Node.js is now available as an optional package: other native nodejs packages include bleno, noble, serialport, socket.io.
			\end{itemize}

		\item Web panel
			\begin{itemize}
				\item Previously, jsonp calls were triggered by the ''jsonp'' query string parameter only. Now, you can use ''callback'' as well.
				\item Added Mailbox support
				\item Various fixes
			\end{itemize}

		\item Bridge
			\begin{itemize}
				\item File.size() now implemented
				\item PHP bridge client (thx Luca Saltoggio)
				\item Bridge is now run with ''-u'' python flag, preventing some random lockups in the Bridge
				\item Resolved conflict with python ''json'' module
			\end{itemize}
	\end{itemize}

Una vez actualizado la versión de \emph{OpenWrt-Yun} siguiendo las instrucciones de la página de Arduino (\emph{http://arduino.cc/en/Tutorial/YunSysupgrade}) solamente tenemos que instalar la librería USB HID por SSH (ya que sigue sin venir por defecto):

	\begin{lstlisting}
opkg update
opkg install kmod-usb-hid
	\end{lstlisting}

Y nos funcionará el lector de códigos de barras USB sin ningún problema, aunque se desenchufe y se vuelva a enchufar.

\subsection{Decodificando el lector de código de barras}

El siguiente problema a resolver es la creación de un script en python que permita la lectura de códigos de barras. Para ello se ha tenido que decodificar los caracteres que envía al sistema operativo, y una vez hecho, comprender como funciona.

El funcionamiento es muy sencillo. Cuando el lector de código de barras encuentra un código válido lo envía al sistema por letras y por último, y es lo que nos ayuda a comprender que ha terminado de enviarnos el código de barras, nos envía dos caracteres seguidos (\emph{Control + j}) que simbolizan el salto de línea (\emph{Line Feed}).

El siguiente script nos permite, una vez conectado el código de barras, leer los eventos y mostrar por pantalla los códigos capturados:

\begin{lstlisting}
#!/usr/bin/python
# -*- coding: utf-8 -*-

import struct
import time
import sys
sys.path.insert(0, '/usr/lib/python2.7/bridge/')

from bridgeclient import BridgeClient as bridgeclient

# Funciones

def esTeclaNumerica(value):
    return value >= 458782 and value <= 458791

def getNumero(value):
    return (value - 458781)%10

def esTeclaLetra(value):
    return (value >= 458756 and value <= 458781)

def getLetra(value):
    posicionValue = value - 458756
    asciiValue = posicionValue + 65
    return str(unichr(asciiValue))

# 458792 -> Intro
# 458976 + 458765 (Control + j => Line Feed)
def esTeclaControl(value):
    return value == 458792 or \
            value == 458976 or \
            value == 458765

# Inicio programa

infile_path = "/dev/input/event1"

#long int, long int, unsigned short, unsigned short, unsigned int
FORMAT = 'llHHI'
EVENT_SIZE = struct.calcsize(FORMAT)

#open file in binary mode
in_file = open(infile_path, "rb")

event = in_file.read(EVENT_SIZE)

teclasPulsadas = dict()
escribiendoLetras = False
codigoBarras = ''
bridgeCliente = bridgeclient()

while event:
    (tv_sec, tv_usec, type, code, value) = struct.unpack(FORMAT, event)

    # Importa este orden de la condici|ó|n, si se altera puede imprimir
    # car|á|cteres escritos muy deprisa en otro orden
    if value not in teclasPulsadas:
        teclasPulsadas[value] = 'S'
    else:
        if esTeclaControl(value) and escribiendoLetras:
            escribiendoLetras = False
            # print codigoBarras

            bridgeCliente.put('codebar', codigoBarras)

            codigoBarras = ''
        elif not esTeclaControl(value) and \
                (esTeclaNumerica(value) or \
                esTeclaLetra(value)):
            escribiendoLetras = True
            if esTeclaNumerica(value):
                codigoBarras += str(getNumero(value))
            elif esTeclaLetra(value):
                codigoBarras += getTeclaLetra(value)
        del teclasPulsadas[value]

    event = in_file.read(EVENT_SIZE)
in_file.close()
\end{lstlisting}